{
  "hash": "753c660996e3864d64cabbb2982163d5",
  "result": {
    "markdown": "---\ntitle: \"Operationalisating Variables\"\noutput: html_document\ndate: \"2023-05-12\"\n---\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nThis section of the course covers how we define and measure variables, and how that can affect our analyses. This is illustrated with an example dataset. If you want to do the exercises yourself, make sure to check if you have all the required libraries installed.\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n```\n:::\n\n\n## Python\n\n### Libraries\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Simple yet exhaustive stats functions.\nimport pingouin as pg\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\n# Statistical models, conducting tests and statistical data exploration\nimport statsmodels.api as sm\n\n# Convenience interface for specifying models using formula strings and DataFrames\nimport statsmodels.formula.api as smf\n```\n:::\n\n:::\n:::\n\n## Exercise 1 - Cycling to work\n\nFor this example, we're interested in finding out whether cycling to work increases staff members' productivity.\n\nDownload the `productivity.csv` file.\n\nThis file contains a fictional dataset that explores the relationship between cycling to work and productivity at work. Each row corresponds to a different staff member at a small Cambridge-based company. There are four variables: `cycle` is a categorical variable denoting whether the individual cycles to work; `distance` is the distance in kilometres between the individual's house and the office; `projects` is the number of projects successfully completed by the individual within the last 6 months; and `mean_hrs` is the average number of hours worked per week in the last 6 months.\n\nAs you may have noticed, we have two variables here that could serve as measures of productivity, and two ways of looking at cycling - whether someone cycles, versus how far they cycle.\n\nFirst, let's start by reading in the data, and visualising it.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the data\nproductivity <- read_csv(\"data/productivity.csv\")\n\n# and have a look\nhead(productivity)\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# load the data\nproductivity_py = pd.read_csv(\"data/productivity.csv\")\n\n# and have a look\nproductivity_py.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  cycle  distance  projects  mean_hrs\n0    no      6.68         2      55.0\n1    no      4.32         3      48.0\n2    no      5.81         2      42.0\n3    no      8.49         2      37.5\n4    no      6.47         4      32.0\n```\n:::\n:::\n\n:::\n\nNow it's time to explore this data in a bit more detail. We can gain some insight by examining our two measures of \"cycling\" (our yes/no categorical variable, and the distance between home and office) and our two measures of \"productivity\" (mean hours worked per week, and projects completed in the last 6 months). \n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# visualise using a boxplot\n\nproductivity %>%\n  ggplot(aes(x = cycle, y = distance)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# compare distance between those who cycle vs those who don't\n# NB: we use a t-test here, since there are only two groups\n\nt.test(distance ~ cycle, data = productivity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tWelch Two Sample t-test\n\ndata:  distance by cycle\nt = 3.4417, df = 10.517, p-value = 0.005871\nalternative hypothesis: true difference in means between group no and group yes is not equal to 0\n95 percent confidence interval:\n 1.801439 8.293561\nsample estimates:\n mean in group no mean in group yes \n           7.3700            2.3225 \n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a boxplot\n(ggplot(productivity_py,\n        aes(x = \"cycle\",\n            y = \"distance\")) +\n     geom_boxplot())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-8-1.png){width=614}\n:::\n:::\n\n\nNext, we compare the distance between those who cycle and those who do not. We use a t-test, since there are only two groups.\n\nHere we use the `ttest()` function from the `pingouin` library. This needs two vectors as input, so we split the data as follows and then run the test:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndist_no_cycle = productivity_py.query('cycle == \"no\"')[\"distance\"]\ndist_yes_cycle = productivity_py.query('cycle == \"yes\"')[\"distance\"]\n\npg.ttest(dist_no_cycle, dist_yes_cycle).transpose()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  T-test\nT               3.441734\ndof            10.516733\nalternative    two-sided\np-val           0.005871\nCI95%        [1.8, 8.29]\ncohen-d         1.683946\nBF10              15.278\npower           0.960302\n```\n:::\n:::\n\n\n:::\n\nLet's look at the second set of variables: the mean hours of worked per week and the number of projects completed in the past 6 months. When visualising this, we need to consider the `projects` as a categorical variable.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# visualise the data\nproductivity %>%\n  ggplot(aes(x = as.factor(projects), y = mean_hrs)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# construct a one-way ANOVA, treating projects as a categorical variable\n\nlm_1 <- lm(mean_hrs ~ as.factor(projects), data = productivity)\nanova(lm_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalysis of Variance Table\n\nResponse: mean_hrs\n                    Df  Sum Sq Mean Sq F value Pr(>F)\nas.factor(projects)  7  936.02  133.72   1.598 0.2066\nResiduals           16 1338.88   83.68               \n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a boxplot\n(ggplot(productivity_py,\n        aes(x = productivity_py['projects'].astype('category'),\n            y = \"mean_hrs\")) +\n     geom_boxplot())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-11-1.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# construct a one-way ANOVA, treating projects as a categorical variable\npg.anova(dv = \"mean_hrs\",\n         between = \"projects\",\n         data = productivity_py,\n         detailed = True).round(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Source        SS  DF       MS      F  p-unc    np2\n0  projects   936.023   7  133.718  1.598  0.207  0.411\n1    Within  1338.883  16   83.680    NaN    NaN    NaN\n```\n:::\n:::\n\n\n:::\n\nWhat does this tell you about these two sets of variables, which (in theory at least!) tap into the same underlying construct, relate to one another? Can you spot any problems, or have you got any concerns at this stage?\n\nIf so, hold that thought.\n\n#### Assessing the effect of cycling on productivity\n\nThe next step is to run some exploratory analyses. Since we're not going to reporting these data in any kind of paper or article, and the whole point is to look at different versions of the same analysis with different variables, we won't worry about multiple comparison correction this time.\n\nWhen treating `mean_hrs` as our response variable, we can use standard linear models approach, since this variable is continuous.\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# visualise using ggplot\n\nproductivity %>%\n  ggplot(aes(x = cycle, y = mean_hrs)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-13-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# run a t-test to compare mean_hrs for those who cycle vs those who don't\n\nt.test(mean_hrs ~ cycle, data = productivity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tWelch Two Sample t-test\n\ndata:  mean_hrs by cycle\nt = -0.51454, df = 11.553, p-value = 0.6166\nalternative hypothesis: true difference in means between group no and group yes is not equal to 0\n95 percent confidence interval:\n -12.803463   7.928463\nsample estimates:\n mean in group no mean in group yes \n          36.6875           39.1250 \n```\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a boxplot\n(ggplot(productivity_py,\n        aes(x = \"cycle\",\n            y = \"mean_hrs\")) +\n     geom_boxplot())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-14-1.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# run a t-test to compare mean_hrs for those who cycle vs those who don't\nhrs_no_cycle = productivity_py.query('cycle == \"no\"')[\"mean_hrs\"]\nhrs_yes_cycle = productivity_py.query('cycle == \"yes\"')[\"mean_hrs\"]\n\npg.ttest(hrs_no_cycle, hrs_yes_cycle).transpose()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                    T-test\nT                -0.514542\ndof              11.553188\nalternative      two-sided\np-val             0.616573\nCI95%        [-12.8, 7.93]\ncohen-d            0.24139\nBF10                 0.427\npower             0.083194\n```\n:::\n:::\n\n\n:::\n\nLet's also look at `mean_hrs` vs `distance`:\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproductivity %>%\n  ggplot(aes(x = distance, y = mean_hrs)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# run a simple linear regression analysis\n\nlm_2 <- lm(mean_hrs ~ distance, data = productivity)\nanova(lm_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalysis of Variance Table\n\nResponse: mean_hrs\n          Df  Sum Sq Mean Sq F value  Pr(>F)  \ndistance   1  473.28  473.28  5.7793 0.02508 *\nResiduals 22 1801.63   81.89                  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a scatterplot\n(ggplot(productivity_py,\n        aes(x = \"distance\",\n            y = \"mean_hrs\")) +\n     geom_point())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-17-1.png){width=614}\n:::\n:::\n\n\nWe can perform a linear regression on these data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# create a linear model\nmodel = smf.ols(formula = \"mean_hrs ~ distance\",\n                data = productivity_py)\n# and get the fitted parameters of the model\nlm_productivity_py = model.fit()\n\n# look at the model output\nprint(lm_productivity_py.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:               mean_hrs   R-squared:                       0.208\nModel:                            OLS   Adj. R-squared:                  0.172\nMethod:                 Least Squares   F-statistic:                     5.779\nDate:                Mon, 26 Jun 2023   Prob (F-statistic):             0.0251\nTime:                        12:48:53   Log-Likelihood:                -85.875\nNo. Observations:                  24   AIC:                             175.8\nDf Residuals:                      22   BIC:                             178.1\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     43.0833      2.711     15.891      0.000      37.461      48.706\ndistance      -1.1912      0.496     -2.404      0.025      -2.219      -0.164\n==============================================================================\nOmnibus:                        1.267   Durbin-Watson:                   1.984\nProb(Omnibus):                  0.531   Jarque-Bera (JB):                0.300\nSkew:                          -0.163   Prob(JB):                        0.861\nKurtosis:                       3.441   Cond. No.                         8.18\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n```\n:::\n:::\n\n\n:::\n\nThis shows us that while `cycle` does not significantly predict `mean_hrs`, `distance` does. (If you had some concerns about the `distance` variable earlier, continue to hold that thought.)\n\nWhen treating `projects` as our response variable, we now have to use a GLM - specifically, we'll use Poisson regression, since `projects` is a count variable. If you aren't familiar with GLMs or Poisson regression, you can expand the box below to find out a bit more (including a link to further materials that will give you more detail).\n\n:::{.callout-note collapse=\"true\"}\n## Generalised linear models and Poisson regression\n\nStandard linear models require that your response or outcome variable be continuous. However, your variable might instead be a probability (e.g., a coin flip, or a proportion), or a count variable, which follow a binomial or Poisson distribution respectively (rather than a normal/Gaussian distribution). To account for this, generalised linear models allow the fitted linear model to be related to the outcome variable via some link function, commonly a log or logit function. Model parameters are also estimated slightly differently; as opposed to the ordinary least squares approach we use in linear regression, GLMs make use of something called maximum likelihood estimation.\n\nPoisson regression is a specific type of GLM, which uses a log function; it's also sometimes referred to as a log-linear model. We use Poisson regression in scenarios where we have an outcome variable that is count data, i.e., data that only takes non-negative integer values, or when modelling contingency tables.\n\nIf you'd like to read more or learn how to fit GLMs yourself, you can find additional course materials [here](https://cambiotraining.github.io/camstats/poisson-regression-count-response.html).\n:::\n\nIf GLMs don't sound interesting to you right now, then don't worry - the output is very similar to your typical linear model!\n\nFirst, we look at `distance` vs `projects`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproductivity %>%\n  ggplot(aes(x = distance, y = projects)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-19-3.png){width=672}\n:::\n\n```{.r .cell-code}\nglm_1 <- glm(projects ~ distance, data = productivity,\n             family = \"poisson\")\nsummary(glm_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = projects ~ distance, family = \"poisson\", data = productivity)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  1.54068    0.15119  10.190   <2e-16 ***\ndistance    -0.06038    0.03301  -1.829   0.0674 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 23.485  on 23  degrees of freedom\nResidual deviance: 19.766  on 22  degrees of freedom\nAIC: 97.574\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a scatterplot\n(ggplot(productivity_py,\n        aes(x = \"distance\",\n            y = \"projects\")) +\n     geom_point())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-20-1.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# create a generalised linear model\nmodel = smf.poisson(formula = \"projects ~ distance\",\n                    data = productivity_py)\n# and get the fitted parameters of the model\nglm1_py = model.fit()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimization terminated successfully.\n         Current function value: 1.949462\n         Iterations 5\n```\n:::\n\n```{.python .cell-code}\n# look at the model output\nprint(glm1_py.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          Poisson Regression Results                          \n==============================================================================\nDep. Variable:               projects   No. Observations:                   24\nModel:                        Poisson   Df Residuals:                       22\nMethod:                           MLE   Df Model:                            1\nDate:                Mon, 26 Jun 2023   Pseudo R-squ.:                 0.03822\nTime:                        12:48:54   Log-Likelihood:                -46.787\nconverged:                       True   LL-Null:                       -48.647\nCovariance Type:            nonrobust   LLR p-value:                   0.05380\n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      1.5407      0.151     10.190      0.000       1.244       1.837\ndistance      -0.0604      0.033     -1.829      0.067      -0.125       0.004\n==============================================================================\n```\n:::\n:::\n\n:::\n\nNext, we look at `cycle` vs `projects`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproductivity %>%\n  ggplot(aes(x = cycle, y = projects)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-22-3.png){width=672}\n:::\n\n```{.r .cell-code}\nglm_2 <- glm(projects ~ cycle, data = productivity,\n             family = \"poisson\")\nsummary(glm_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = projects ~ cycle, family = \"poisson\", data = productivity)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)   0.9163     0.2236   4.098 4.17e-05 ***\ncycleyes      0.5596     0.2535   2.207   0.0273 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 23.485  on 23  degrees of freedom\nResidual deviance: 18.123  on 22  degrees of freedom\nAIC: 95.931\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a scatterplot\n(ggplot(productivity_py,\n        aes(x = \"cycle\",\n            y = \"projects\")) +\n     geom_boxplot())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-23-1.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# create a generalised linear model\nmodel = smf.poisson(formula = \"projects ~ cycle\",\n                    data = productivity_py)\n# and get the fitted parameters of the model\nglm2_py = model.fit()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimization terminated successfully.\n         Current function value: 1.915222\n         Iterations 5\n```\n:::\n\n```{.python .cell-code}\n# look at the model output\nprint(glm2_py.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          Poisson Regression Results                          \n==============================================================================\nDep. Variable:               projects   No. Observations:                   24\nModel:                        Poisson   Df Residuals:                       22\nMethod:                           MLE   Df Model:                            1\nDate:                Mon, 26 Jun 2023   Pseudo R-squ.:                 0.05512\nTime:                        12:48:55   Log-Likelihood:                -45.965\nconverged:                       True   LL-Null:                       -48.647\nCovariance Type:            nonrobust   LLR p-value:                   0.02057\n================================================================================\n                   coef    std err          z      P>|z|      [0.025      0.975]\n--------------------------------------------------------------------------------\nIntercept        0.9163      0.224      4.098      0.000       0.478       1.355\ncycle[T.yes]     0.5596      0.254      2.207      0.027       0.063       1.057\n================================================================================\n```\n:::\n:::\n\n:::\n\nThis shows us that `cycle` significantly predicts `projects`, meaning the number of projects that get completed is not completely random, but some of the variance in that can be explained by whether a person cycles to work, or not. In contrast, `distance` does not appear to be a significant predictor of `projects` (although it's only marginally non-significant). This is the opposite pattern, more or less, to the one we had for `mean_hrs`.\n\n#### That thought you were holding...\n\nThose of you who are discerning may have noticed that the `distance` variable is problematic as a measure of \"cycling to work\" in this particular dataset - this is because the dataset includes all the distances to work for the staff members who *don't* cycle, as well as those who do.\n\nWhat happens if we remove those values, and look at the relationship between `distance` and our response variables again?\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the filter function to retain only the rows where the staff member cycles\n\nproductivity_cycle <- productivity %>%\n  filter(cycle == \"yes\")\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nproductivity_cycle_py = productivity_py[productivity_py[\"cycle\"] == \"yes\"]\n```\n:::\n\n:::\n\nWe'll repeat earlier visualisations and analyses, this time with the colour aesthetic helping us to visualise how the `cycle` variable affects the relationships between `distance`, `mean_hrs` and `projects`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproductivity %>%\n  ggplot(aes(x = distance, y = mean_hrs, colour = cycle)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n```{.r .cell-code}\nlm_3 <- lm(mean_hrs ~ distance, data = productivity_cycle)\nanova(lm_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalysis of Variance Table\n\nResponse: mean_hrs\n          Df  Sum Sq Mean Sq F value Pr(>F)\ndistance   1  202.77 202.766  2.6188 0.1279\nResiduals 14 1083.98  77.427               \n```\n:::\n\n```{.r .cell-code}\nproductivity %>%\n  ggplot(aes(x = distance, y = projects, colour = cycle)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-27-2.png){width=672}\n:::\n\n```{.r .cell-code}\nglm_3 <- glm(projects ~ distance, data = productivity_cycle,\n             family = \"poisson\")\nsummary(glm_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = projects ~ distance, family = \"poisson\", data = productivity_cycle)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  1.55102    0.16292    9.52   <2e-16 ***\ndistance    -0.03380    0.05204   -0.65    0.516    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 15.591  on 15  degrees of freedom\nResidual deviance: 15.144  on 14  degrees of freedom\nAIC: 70.869\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a scatterplot\n(ggplot(productivity_py,\n        aes(x = \"distance\",\n            y = \"mean_hrs\",\n            colour = \"cycle\")) +\n     geom_point())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-28-1.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# create a linear model\nmodel = smf.ols(formula = \"mean_hrs ~ distance\",\n                data = productivity_cycle_py)\n# and get the fitted parameters of the model\nlm_dist_cycle_py = model.fit()\n\n# look at the model output\nprint(lm_dist_cycle_py.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:               mean_hrs   R-squared:                       0.158\nModel:                            OLS   Adj. R-squared:                  0.097\nMethod:                 Least Squares   F-statistic:                     2.619\nDate:                Mon, 26 Jun 2023   Prob (F-statistic):              0.128\nTime:                        12:48:56   Log-Likelihood:                -56.429\nNo. Observations:                  16   AIC:                             116.9\nDf Residuals:                      14   BIC:                             118.4\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     42.4204      2.998     14.151      0.000      35.991      48.850\ndistance      -1.4189      0.877     -1.618      0.128      -3.299       0.462\n==============================================================================\nOmnibus:                        4.148   Durbin-Watson:                   2.906\nProb(Omnibus):                  0.126   Jarque-Bera (JB):                2.008\nSkew:                          -0.820   Prob(JB):                        0.366\nKurtosis:                       3.565   Cond. No.                         4.85\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualise using a scatterplot\n(ggplot(productivity_py,\n        aes(x = \"distance\",\n            y = \"projects\",\n            colour = \"cycle\")) +\n     geom_point())\n```\n\n::: {.cell-output-display}\n![](02-operationalisation_files/figure-html/unnamed-chunk-30-3.png){width=614}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# create a poisson model\nmodel = smf.poisson(formula = \"projects ~ distance\",\n                    data = productivity_cycle_py)\n# and get the fitted parameters of the model\nlm_proj_cycle_py = model.fit()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimization terminated successfully.\n         Current function value: 2.089649\n         Iterations 4\n```\n:::\n\n```{.python .cell-code}\n# look at the model output\nprint(lm_proj_cycle_py.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          Poisson Regression Results                          \n==============================================================================\nDep. Variable:               projects   No. Observations:                   16\nModel:                        Poisson   Df Residuals:                       14\nMethod:                           MLE   Df Model:                            1\nDate:                Mon, 26 Jun 2023   Pseudo R-squ.:                0.006655\nTime:                        12:48:57   Log-Likelihood:                -33.434\nconverged:                       True   LL-Null:                       -33.658\nCovariance Type:            nonrobust   LLR p-value:                    0.5033\n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      1.5510      0.163      9.520      0.000       1.232       1.870\ndistance      -0.0338      0.052     -0.650      0.516      -0.136       0.068\n==============================================================================\n```\n:::\n:::\n\n:::\n\nAh. Turns out we were right to be concerned; when staff members who don't cycle are removed from the dataset, the significant relationship that we saw earlier between `distance` and `mean_hrs` disappears. And the marginally non-significant relationship we observed between `distance` and `projects` becomes much less significant.\n\nThis leaves us with just one significant result: `projects ~ cycle`. But if we really were trying to report on these data, in a paper or report of some kind, we'd need to think very carefully about how much we *trust* this result, or whether perhaps we've stumbled on a false positive by virtue of running so many tests. We may also want to think carefully about whether or not we're happy with these definitions of the variables; for instance, is the number of projects completed really the best metric for productivity at work?\n\n## Summary\n\n::: {.callout-tip}\n#### Key Points\n\n- There are multiple ways to operationalise a variable, which may affect whether the variable is categorical or continuous\n- The nature of the response variable will alter what type of model can be fitted to the dataset\n- Some operationalisations may better capture your variable of interest than others\n- If you do not effectively operationalise your variable in advance, you may find yourself \"cherry-picking\" your dataset\n:::",
    "supporting": [
      "02-operationalisation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}